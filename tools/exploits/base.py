"""Ghost Girl — Base exploit class.

All exploit modules inherit from BaseExploit and implement:
  - check()   → verify the target is vulnerable (optional)
  - exploit() → execute the exploit
  - cleanup() → remove artifacts (optional)
"""

import abc
import requests
import urllib3

# Suppress SSL warnings for self-signed certs
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class ExploitError(Exception):
    """Raised when an exploit fails."""
    pass


class BaseExploit(abc.ABC):
    """Abstract base class for all exploit modules."""

    # Subclasses must define these
    name = "base"
    description = "Base exploit class"
    author = "ghost-girl"
    references = []  # CVE IDs, URLs, etc.

    # Options: dict of {name: {"required": bool, "description": str, "default": value}}
    options = {}

    def __init__(self):
        self._values = {}
        self.session = requests.Session()
        self.session.verify = False
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0"
        })

        # Initialize defaults
        for key, opt in self.options.items():
            if "default" in opt:
                self._values[key] = opt["default"]

    def set_option(self, key, value):
        """Set an exploit option."""
        key = key.upper()
        if key not in self.options:
            raise ExploitError(f"Unknown option: {key}")
        self._values[key] = value

    def get(self, key):
        """Get an option value."""
        key = key.upper()
        return self._values.get(key)

    def validate_options(self):
        """Check that all required options are set."""
        missing = []
        for key, opt in self.options.items():
            if opt.get("required", False) and key not in self._values:
                missing.append(key)
        if missing:
            raise ExploitError(f"Missing required options: {', '.join(missing)}")

    def target_url(self, path=""):
        """Build target URL from RHOST/RPORT/SSL options."""
        rhost = self.get("RHOST") or "127.0.0.1"
        rport = self.get("RPORT")
        ssl = self.get("SSL")
        scheme = "https" if ssl else "http"
        if rport and str(rport) not in ("80", "443"):
            return f"{scheme}://{rhost}:{rport}{path}"
        return f"{scheme}://{rhost}{path}"

    def check(self):
        """Check if target is vulnerable. Returns (bool, message)."""
        return False, "Check not implemented"

    @abc.abstractmethod
    def exploit(self):
        """Execute the exploit. Returns (bool, message)."""
        pass

    def cleanup(self):
        """Remove artifacts from target. Override in subclass if needed."""
        pass

    def info(self):
        """Return formatted exploit info."""
        lines = [
            f"  Name:        {self.name}",
            f"  Description: {self.description}",
            f"  Author:      {self.author}",
        ]
        if self.references:
            lines.append(f"  References:  {', '.join(self.references)}")
        lines.append("")
        lines.append("  Options:")
        for key, opt in self.options.items():
            req = "*" if opt.get("required") else " "
            default = f" [default: {opt['default']}]" if "default" in opt else ""
            val = self._values.get(key, "")
            current = f" = {val}" if val else ""
            lines.append(f"    {req} {key:<16} {opt['description']}{default}{current}")
        return "\n".join(lines)
