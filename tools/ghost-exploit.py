#!/usr/bin/env python3
"""Ghost Girl — Exploit runner.

Discovers and runs exploit modules from tools/exploits/.

Usage:
  python3 ghost-exploit.py --list
  python3 ghost-exploit.py wp_crop_rce --RHOST blog.thm --USERNAME admin --PASSWORD pass --LHOST 10.x.x.x --LPORT 4444
  python3 ghost-exploit.py wp_crop_rce --check --RHOST blog.thm
  python3 ghost-exploit.py wp_crop_rce --info
"""

import argparse
import importlib
import inspect
import os
import sys

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)
sys.path.insert(0, PROJECT_ROOT)

from tools.lib.output import banner, status, success, error, warning, data, section, table
from tools.lib.config import EXPLOITS_DIR
from tools.exploits.base import BaseExploit, ExploitError


def discover_modules():
    """Scan tools/exploits/ for exploit modules."""
    modules = {}
    for fname in os.listdir(EXPLOITS_DIR):
        if fname.startswith("_") or fname == "base.py" or not fname.endswith(".py"):
            continue
        module_name = fname[:-3]
        try:
            mod = importlib.import_module(f"tools.exploits.{module_name}")
            # Find the BaseExploit subclass in this module
            for attr_name in dir(mod):
                attr = getattr(mod, attr_name)
                if (inspect.isclass(attr)
                        and issubclass(attr, BaseExploit)
                        and attr is not BaseExploit):
                    modules[module_name] = attr
                    break
        except Exception as e:
            warning(f"Failed to load module {module_name}: {e}")
    return modules


def list_modules(modules):
    """Print available exploit modules."""
    section("Available Exploits")
    if not modules:
        warning("No exploit modules found in tools/exploits/")
        return
    rows = []
    for name, cls in sorted(modules.items()):
        instance = cls()
        refs = ", ".join(instance.references) if instance.references else "-"
        rows.append([name, instance.description, refs])
    table(["MODULE", "DESCRIPTION", "REFERENCES"], rows)
    print()


def main():
    banner("Ghost Exploit")

    # Discover modules first
    modules = discover_modules()

    # Build parser
    parser = argparse.ArgumentParser(
        description="Ghost Exploit — Exploit runner",
        add_help=True
    )
    parser.add_argument("module", nargs="?", default=None,
                        help="Exploit module name")
    parser.add_argument("--list", action="store_true",
                        help="List available exploits")
    parser.add_argument("--check", action="store_true",
                        help="Check if target is vulnerable (don't exploit)")
    parser.add_argument("--info", action="store_true",
                        help="Show exploit info and options")
    parser.add_argument("--cleanup", action="store_true",
                        help="Run cleanup on target")

    # Parse known args first, then handle dynamic --OPTION args
    args, remaining = parser.parse_known_args()

    if args.list:
        list_modules(modules)
        return

    if not args.module:
        parser.print_help()
        print()
        list_modules(modules)
        return

    if args.module not in modules:
        error(f"Unknown module: {args.module}")
        list_modules(modules)
        sys.exit(1)

    # Instantiate exploit
    exploit = modules[args.module]()

    # Parse dynamic options (--RHOST value, --LPORT value, etc.)
    i = 0
    while i < len(remaining):
        arg = remaining[i]
        if arg.startswith("--"):
            key = arg[2:].upper()
            if i + 1 < len(remaining) and not remaining[i + 1].startswith("--"):
                value = remaining[i + 1]
                i += 2
            else:
                value = "true"
                i += 1
            try:
                exploit.set_option(key, value)
            except ExploitError as e:
                error(str(e))
                print(f"\n{exploit.info()}")
                sys.exit(1)
        else:
            warning(f"Ignoring unknown argument: {arg}")
            i += 1

    # Info mode
    if args.info:
        print(exploit.info())
        return

    # Check mode
    if args.check:
        try:
            exploit.validate_options()
        except ExploitError as e:
            error(str(e))
            print(f"\n{exploit.info()}")
            sys.exit(1)

        status(f"Checking {exploit.name} against {exploit.get('RHOST')}...")
        vuln, msg = exploit.check()
        if vuln:
            success(f"VULNERABLE: {msg}")
            data("VULNERABLE", "true")
        else:
            warning(f"Not vulnerable: {msg}")
            data("VULNERABLE", "false")
        return

    # Exploit mode
    try:
        exploit.validate_options()
    except ExploitError as e:
        error(str(e))
        print(f"\n{exploit.info()}")
        sys.exit(1)

    section(f"Exploit: {exploit.name}")
    status(f"Target: {exploit.get('RHOST')}")
    if exploit.get("LHOST"):
        status(f"Callback: {exploit.get('LHOST')}:{exploit.get('LPORT')}")

    try:
        ok, msg = exploit.exploit()
        if ok:
            success(f"Exploit succeeded: {msg}")
            data("EXPLOIT_RESULT", "success")
        else:
            error(f"Exploit failed: {msg}")
            data("EXPLOIT_RESULT", "failed")
            sys.exit(1)
    except ExploitError as e:
        error(f"Exploit error: {e}")
        data("EXPLOIT_RESULT", "error")
        sys.exit(1)
    except KeyboardInterrupt:
        warning("Interrupted")
        sys.exit(130)

    # Cleanup if requested
    if args.cleanup:
        status("Running cleanup...")
        exploit.cleanup()
        success("Cleanup done")


if __name__ == "__main__":
    main()
